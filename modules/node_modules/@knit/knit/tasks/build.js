/* @flow */

import type { TModules } from '@knit/knit-core';

const Listr = require('listr');
const del = require('del');
const rx = require('@reactivex/rxjs');

const knit = require('@knit/knit-core');
const needle = require('@knit/needle');

const build = require('../lib/build');

type TCtx = {
  updated: TModules,
};

const createBuildTasks = (module: string) => {
  const pkg = knit.readPkg(module, needle.paths);
  return ({
    title: module,
    skip: () => pkg && pkg.build === false && 'build set to false',
    task: () => rx.Observable.create(observer => {
      observer.next('removing old builds');
      return del([knit.pathJoin(needle.paths.modules, module, needle.paths.distStub)])
    .then(() => {
      observer.next('building for commonjs');
      return build.buildModuleLib(module);
    })
    .then(() => {
      if (pkg && !pkg.browser) {
        return observer.complete();
      }

      observer.next('building for es6');
      return build.buildModuleEs6(module)
      .then(() => {
        observer.next('building for umd');
        return build.buildModuleUmd(module);
      })
      .then(() => observer.complete())
      .catch(err => observer.error(err));
    })
    .catch(err => observer.error(err));
    }),
  });
};

const tasks = [
  {
    title: 'rebuilding project',
    skip: () => needle.pkg.private && 'project package.json set to private',
    task: () => del(
      [knit.pathJoin(needle.paths.dist)]
    ).then(() =>
       build.buildProjectUmd(needle.paths.entryStub)
    ),
  },
  {
    title: 'rebuilding updated modules',
    task: (ctx: TCtx) => (
      new Listr(ctx.updated.map(createBuildTasks), { concurrent: true })
    ),
  },
];

module.exports = tasks;
