/* @flow */

import fs from 'fs-extra';

import isScoped from '@knit/is-scoped';
import pathJoin from '@knit/path-join';
import getPackageFromDir from '@knit/get-package-from-dir';
import readPkg from '@knit/read-pkg';

import type { TPaths } from '@knit/needle';

type TModules = Array<string>;

type TFindPackages = (p: TPaths) => TModules;
export const findPackages: TFindPackages = (paths) => {
  try {
    return fs.readdirSync(paths.modules)
      .reduce((acc, d) => (
        isScoped(d)
          ? acc.concat(fs.readdirSync(pathJoin(paths.modules, d)).map(dir => pathJoin(d, dir)))
          : acc.concat(d)
      ), [])
      .filter(d => fs.statSync(pathJoin(paths.modules, d)).isDirectory())
      .map(getPackageFromDir);
  } catch (err) {
    throw {
      message: 'Modules directory could not be read.',
      stderr: `Make sure your modules are in \`${paths.modulesStub}\``,
    };
  }
};

type TFindPublicPackages = (p: TPaths) => TModules;
export const findPublicPackages: TFindPublicPackages = (paths) => (
   findPackages(paths).filter(m => {
     const pkg = readPkg(m, paths);
     return pkg && !pkg.private;
   })
);

