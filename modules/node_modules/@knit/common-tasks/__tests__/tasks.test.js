/* @flow */

jest.unmock('fs-extra');
jest.unmock('read-pkg');

const SilentRenderer = require('listr-silent-renderer');
const Listr = require('listr');


const modules = require('../tasks/modules');
const updated = require('../tasks/updated');
const packages = require('../tasks/packages');

jest.mock('@knit/needle', () => {
  const path = require('path');

  return ({
    paths: {
      modules: path.resolve(path.join(process.cwd(), '__fixtures__', 'modules')),
      modulesStub: 'modules',
      distStub: '',
    },
  });
});

describe('modules', () => {
  it('adds a list of all modules to ctx.modules', async () => {
    const ctx = await new Listr(modules, { renderer: SilentRenderer }).run();
    expect(ctx.modules).toEqual(['@scope/module-b', 'module-a']);
    expect(ctx.updated).toBeFalsy();
  });
});

describe('updated', () => {
  it('adds modules to ctx.updated when --force is passed', async () => {
    const mods = ['@scope/module-b', 'module-a'];
    const ctx = await new Listr(updated, { renderer: SilentRenderer }).run({ modules: mods, force: true });
    expect(ctx.modules).toEqual(mods);
    expect(ctx.updated).toEqual(mods);
  });
  it('adds limits scope of modules --force and --scope is passed', async () => {
    const mods = ['@scope/module-b', 'module-a'];
    const ctx = await new Listr(updated, { renderer: SilentRenderer }).run({ modules: mods, scope: ['a'], force: true });
    expect(ctx.modules).toEqual(mods);
    expect(ctx.updated).toEqual(['module-a']);
  });
});

describe('packages', () => {
  it('adds a mapping of modules => package.json contents to ctx.pkgs', async () => {
    const ctx = await new Listr([...modules, ...packages], { renderer: SilentRenderer }).run();
    expect(ctx.pkgs).toEqual({ '@scope/module-b': { name: '@scope/module-b' }, 'module-a': { name: 'module-a' } });
  });
});
