/* @flow */

import type { TModules } from '@knit/knit-core';

const execa = require('execa');

const knit = require('@knit/knit-core');
const needle = require('@knit/needle');

type TCtx = {
  force: boolean,
  scope: Array<string>,
  ignore: Array<string>,
  tag: ?string,
  modules: TModules,
  updated: TModules,
};

const tasks = [
  {
    title: 'getting last tag',
    skip: (ctx: TCtx) => ctx.tag || ctx.updated || ctx.force,
    task: (ctx: TCtx) => execa.stdout('git', ['describe', '--abbrev=0', '--tags']).then(tag => {
      ctx.tag = tag;
    }).catch(() => execa.stdout('git', ['rev-list', '--max-parents=0', 'HEAD']).then(commit => {
      ctx.tag = commit;
    })).catch(() => {
      // no commit history
      ctx.tag = null;
    }),
  },
  {
    title: 'determining updated modules since last release',
    skip: (ctx: TCtx) => ctx.updated && `${ctx.updated.length} modules already found.`,
    task: (ctx: TCtx) => {
      if (ctx.tag && !ctx.force) {
        const modified = knit.findModifiedSince(ctx.modules, ctx.tag, needle.paths);
        return knit.findUpdatedModules(ctx.modules, modified, needle.paths).then(updated => {
          ctx.updated = updated;
          if (ctx.scope) {
            ctx.updated = ctx.updated.filter(module => ctx.scope.some(pattern => module.match(new RegExp(pattern))));
          }
          if (ctx.ignore) {
            ctx.updated = ctx.updated.filter(module => !ctx.ignore.some(pattern => module.match(new RegExp(pattern))));
          }
        });
      }

      ctx.updated = ctx.modules;
      if (ctx.scope) {
        ctx.updated = ctx.updated.filter(module => ctx.scope.some(pattern => module.match(new RegExp(pattern))));
      }
      if (ctx.ignore) {
        ctx.updated = ctx.updated.filter(module => !ctx.ignore.some(pattern => module.match(new RegExp(pattern))));
      }

      return ctx;
    },
  },
];

module.exports = tasks;
