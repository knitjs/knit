/* @flow */

import type { TPkgJson, TPkgJsonDeps, TPaths } from '@knit/needle';

import depcheck from '@knit/depcheck';
import pathJoin from '@knit/path-join';
import readPkg from '@knit/read-pkg';

export type TModules = Array<string>;

type TFindDependencies = (m: string, p: TPaths) => Promise<TModules>;
export const findDependencies: TFindDependencies = (mod, paths) => (
   depcheck(pathJoin(paths.modules, mod))
    .then(res => Object.keys(res.using))
    .then(using => {
      const pkg = readPkg(mod, paths);
      const deps = Object.keys((pkg || {}).dependencies || {});

      return using.concat(deps);
    })
    .then(using => using.reduce((acc, d) => (acc.includes(d) ? acc : acc.concat(d)), []))
    .then(using => using.sort())
    .catch(e => {
      throw e;
    })
);

type TFindMissingDependencies = (u: TModules, m: TModules, d: TPkgJsonDeps) => TModules;
export const findMissingDependencies: TFindMissingDependencies = (using, modules, deps) => {
  const installed = Object.keys(deps);

  return using
    .filter(m => !installed.includes(m) && !modules.includes(m))
    .reduce((acc, d) => (acc.includes(d) ? acc : acc.concat(d)), []);
};

type TFindUnusedDependencies = (u: TModules, m: TModules, d: TPkgJsonDeps) => TModules;
export const findUnusedDependencies: TFindUnusedDependencies = (using, modules, deps) => {
  const installed = Object.keys(deps);

  return installed
    .filter(m => !using.includes(m) && !modules.includes(m))
    .reduce((acc, d) => (acc.includes(d) ? acc : acc.concat(d)), []);
};

type TFindInternalDependencies = (u: TModules, m: TModules) => TModules;
export const findInternalDependencies: TFindInternalDependencies = (using, modules) => (
   using
    .filter(m => modules.includes(m))
    .reduce((acc, d) => (acc.includes(d) ? acc : acc.concat(d)), [])
);

type TFindAllDependencies = (m: TModules, p: TPaths) => Promise<TModules>;
export const findAllDependencies: TFindAllDependencies = async (modules, paths) => (
  (await Promise.all(modules.reduce((acc, mod) => {
    const deps = findDependencies(mod, paths);
    return acc.concat(deps);
  }, [])))
  .reduce((a, m) => (
    (a.includes(m) ? a : a.concat(m))
  ), [])
);

type TFindAllMissingDependencies = (m: TModules, p: TPaths, rootPkg: TPkgJson) => Promise<TModules>;
export const findAllMissingDependencies: TFindAllMissingDependencies = (modules, paths, rootPkg) => (
  findAllDependencies(modules, paths).then(using => (
    findMissingDependencies(using, modules, rootPkg.dependencies)
  ))
);

type TFindAllUnusedDependencies = (m: TModules, p: TPaths, rootPkg: TPkgJson) => Promise<TModules>;
export const findAllUnusedDependencies: TFindAllUnusedDependencies = (modules, paths, rootPkg) => (
  findAllDependencies(modules, paths).then(using => (
    findUnusedDependencies(using, modules, rootPkg.dependencies)
  ))
);

type TMakeDependencyMap = (m: TModules, p: TPaths) => Promise<{[k: string]: TModules}>;
export const makeDependencyMap: TMakeDependencyMap = async (modules, paths) => (
  modules.reduce(async (acc, mod) => ({
    ...await acc,
    [mod]: await findDependencies(mod, paths),
  }), {})
);
