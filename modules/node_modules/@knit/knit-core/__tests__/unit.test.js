/* flow */

const path = require('path');

const mockPath = path;
const knit = require('..');

const PATHS = { modules: '', modulesStub: '', lib: 'lib', jsnext: 'jsnext', umd: 'umd' };

jest.mock('@knit/depcheck', () => (
  jest.fn((module) => (
    new Promise(resolve => resolve({
      using: {
        [mockPath.join('@scope', 'package')]: { modA: [], modB: [] },
        packageB: { modC: [], modD: [] },
        modD: {},
      }[module],
    }))
  ))
));

describe('isScoped', () => {
  const is = knit.isScoped;

  it('knows if package is scoped', () => {
    expect(is('@scope/package')).toBe(true);
  });
  it('knows if package is unscoped', () => {
    expect(is('package')).toBe(false);
  });
});

describe('getModuleName', () => {
  const mn = knit.getModuleName;

  it('finds module name', () => {
    expect(mn('package')).toBe('package');
  });
  it('finds module name of scoped module', () => {
    expect(mn('@scope/package')).toBe('package');
  });
});

describe('pathJoin', () => {
  const pj = knit.pathJoin;
  it('still works like path.join', () => {
    expect(pj('foo', 'bar', 'module')).toBe(path.join('foo', 'bar', 'module'));
  });
  it('create path when passed scoped module', () => {
    expect(pj('foo', 'bar', '@scope/package')).toBe(path.join('foo', 'bar', '@scope', 'package'));
  });
  it('keep abs path', () => {
    expect(pj('/foo', 'bar', 'package')).toBe(path.join('/foo', 'bar', 'package'));
  });
});

describe('getModuleFromDir', () => {
  const mn = knit.getModuleFromDir;

  it('finds module name from dir', () => {
    expect(mn('package')).toBe('package');
  });
  it('finds module name from scoped dir', () => {
    expect(mn(path.join('@scope', 'package'))).toBe('@scope/package');
  });
});

describe('readPkg', () => {
  const rp = knit.readPkg;

  it('returns json if package exists', () => {
    require('read-pkg').__setMockPackages({
      [path.join('@scope', 'package')]: { name: '@scope/package' },
    });
    expect(rp('@scope/package', PATHS)).toEqual({ name: '@scope/package' });
  });
  it('throws if package is missing', () => {
    expect(rp('DNE', PATHS)).toThrow();
  });
});

describe('findDependencies', () => {
  const fd = knit.findDependencies;

  it('returns list of modules', async () => {
    const ms = await fd('@scope/package', PATHS);
    expect(ms).toEqual(['modA', 'modB']);
  });
});

describe('findAllDependencies', () => {
  const fad = knit.findAllDependencies;

  it('returns list of dependencies used by modules', async () => {
    const ms = await fad(['@scope/package', 'packageB'], PATHS);
    expect(ms).toEqual(['modA', 'modB', 'modC', 'modD']);
  });
});

describe('findMissingDependencies', () => {
  const md = knit.findMissingDependencies;

  it('returns list of missing modules', () => {
    const ms = md(['modA'], [], {});
    expect(ms).toEqual(['modA']);
  });
  it('returns empty list when nothing missing', () => {
    const ms = md(['modA'], [], { modA: '1' });
    expect(ms).toEqual([]);
  });
  it('does not consider internal modules as missing', () => {
    const ms = md(['modA', 'modB'], ['modB'], { modA: '1' });
    expect(ms).toEqual([]);
  });
});

describe('findAllMissingDependencies', () => {
  const famd = knit.findAllMissingDependencies;

  it('returns list of dependencies used by modules', async () => {
    const ms = await famd(
      ['@scope/package', 'packageB'],
      PATHS,
      { dependencies: { modA: '1', modC: '1' } }
      );
    expect(ms).toEqual(['modB', 'modD']);
  });
});

describe('findUnusedDependencies', () => {
  const ud = knit.findUnusedDependencies;

  it('returns list of unused modules', () => {
    const ms = ud([], [], { modA: 1 });
    expect(ms).toEqual(['modA']);
  });
  it('returns empty list when nothing unused', () => {
    const ms = ud(['modA'], [], { modA: '1' });
    expect(ms).toEqual([]);
  });
  it('does not consider internal modules as unused', () => {
    const ms = ud(['modA'], ['modB'], { modA: '1' });
    expect(ms).toEqual([]);
  });
});

describe('findAllUnusedDependencies', () => {
  const faud = knit.findAllUnusedDependencies;

  it('returns list of unused dependencies', async () => {
    const ms = await faud(
      ['@scope/package', 'packageB'],
      PATHS,
      { dependencies: { modA: '1', modC: '1', modE: '1' } }
      );
    expect(ms).toEqual(['modE']);
  });
});

describe('findInternalDependencies', () => {
  const id = knit.findInternalDependencies;

  it('returns list of used internal modules', () => {
    const ms = id(['modA', 'modB'], ['modA']);
    expect(ms).toEqual(['modA']);
  });
});

describe('findModules', () => {
  const fm = knit.findModules;

  it('returns list of modules from directories', () => {
    require('fs-extra').__setMockFiles({
      '': ['moduleA', 'moduleB'],
    });
    expect(fm(PATHS)).toEqual(['moduleA', 'moduleB']);
  });
  it('steps into @scoped directories', () => {
    require('fs-extra').__setMockFiles({
      '': ['moduleA', '@moduleB'],
      '@moduleB': ['moduleC'],
    });
    expect(fm(PATHS)).toEqual(['moduleA', '@moduleB/moduleC']);
  });
});

describe('findPublicModules', () => {
  const fpm = knit.findPublicModules;

  it('returns list of modules that have a package.json and have not set `private: true`', () => {
    require('fs-extra').__setMockFiles({
      '': ['moduleA', 'moduleB'],
    });
    require('read-pkg').__setMockPackages({
      moduleA: { name: 'moduleA' },
      moduleB: { name: 'moduleB', private: true },
    });
    expect(fpm(PATHS)).toEqual(['moduleA']);
  });
});

describe('makeDependencyMap', () => {
  const mdm = knit.makeDependencyMap;

  it('returns a map of modules and their dependencies', async () => {
    const m = await mdm(['@scope/package', 'packageB'], PATHS);
    expect(m).toEqual({
      '@scope/package': ['modA', 'modB'],
      packageB: ['modC', 'modD'],
    });
  });
});

describe('resolveDependencies', () => {
  const rd = knit.resolveCascadingUpdates;
  const modules = ['mod1', 'mod2', 'mod3', 'mod4'];

  it('returns an empty array when there are no modified modules', () => {
    expect(rd(modules, {}, [])).toEqual([]);
  });
  it('returns modified modules with no mapping', () => {
    const modified = ['mod1', 'mod2'];
    expect(rd(modules, {}, modified)).toEqual(modified);
  });
  it('handles one level of dependencies', () => {
    const modified = ['mod1'];
    const mapping = {
      mod1: [],
      mod2: ['mod1'],
      mod3: ['mod1'],
    };
    const resolved = ['mod1', 'mod2', 'mod3'];
    expect(rd(modules, mapping, modified)).toEqual(resolved);
  });
  it('handles one level of multiple dependencies', () => {
    const modified = ['mod0'];
    const mapping = {
      mod0: [],
      mod1: ['mod0'],
      mod2: ['mod0', 'mod1'],
      mod3: ['mod0', 'mod1'],
      mod4: ['mod0', 'mod2', 'mod3'],
    };
    const resolved = ['mod0', 'mod1', 'mod2', 'mod3', 'mod4'];
    expect(rd(modules, mapping, modified)).toEqual(resolved);
  });
  it('handles multiple modified modules', () => {
    const modified = ['mod1', 'mod2'];
    const mapping = {
      mod0: [],
      mod1: ['mod0'],
      mod2: ['mod0', 'mod1'],
      mod3: ['mod0'],
      mod4: ['mod2', 'mod3'],
    };
    const resolved = ['mod1', 'mod2', 'mod4'];
    expect(rd(modules, mapping, modified)).toEqual(resolved);
  });
  it('handles multiple level dependencies', () => {
    const modified = ['mod0'];
    const mapping = {
      mod0: [],
      mod1: ['mod0'],
      mod2: ['mod1'],
      mod3: ['mod2'],
      mod4: ['mod3'],
      mod5: [],
    };
    const resolved = ['mod0', 'mod1', 'mod2', 'mod3', 'mod4'];
    expect(rd(modules, mapping, modified)).toEqual(resolved);
  });
  it('handles cyclic dependencies', () => {
    const modified = ['mod0'];
    const mapping = {
      mod0: ['mod1'],
      mod1: ['mod0'],
    };
    const resolved = ['mod0', 'mod1'];
    expect(rd(modules, mapping, modified)).toEqual(resolved);
  });
});

describe('findUpdatedModules', () => {
  const fum = knit.findUpdatedModules;

  it('returns a map of modules and their dependencies', async () => {
    const m = await fum(['@scope/package', 'packageB', 'modD'], ['modD'], PATHS);
    expect(m).toEqual(['modD', 'packageB']);
  });
});

describe('getDependencyVersion', () => {
  const gdv = knit.getDependencyVersion;
  const modules = {
    updated: ['moduleB'],
    internal: ['moduleC'],
  };
  const params = {
    paths: PATHS,
    nextVersion: '2.2.2',
    rootPkg: { dependencies: { moduleA: '1.1.1' } },
  };
  it('returns version found in root package.json', () => {
    expect(gdv('moduleA', modules, params)).toBe('1.1.1');
  });
  it('returns nextVersion if dependency is updated internal module', () => {
    expect(gdv('moduleB', modules, params)).toBe('2.2.2');
  });
  it('returns current module version if not updated', () => {
    require('read-pkg').__setMockPackages({
      moduleC: { name: 'moduleC', version: '0.1.0' },
    });
    expect(gdv('moduleC', modules, params)).toBe('0.1.0');
  });
  it('otherwise throws an error ', () => {
    expect(() => gdv('moduleD', modules, params)).toThrow();
  });
});

describe('getPeerDependencyVersion', () => {
  const gpv = knit.getPeerDependencyVersion;

  it('returns version found in module package.json peerDependencies', () => {
    const params = {
      paths: PATHS,
      pkg: { peerDependencies: { moduleA: '>=3' } },
      rootPkg: { peerDependencies: { moduleA: '*' } },
    };
    expect(gpv('moduleA', {}, params)).toBe('>=3');
  });
  it('returns version found in root package.json peerDependencies', () => {
    const params = {
      paths: PATHS,
      pkg: {},
      rootPkg: { peerDependencies: { moduleA: '^1' } },
    };
    expect(gpv('moduleA', {}, params)).toBe('^1');
  });
  it('returns devDependencies version truncates to major version if peer version is *', () => {
    const params = {
      paths: PATHS,
      pkg: {},
      rootPkg: { devDependencies: { moduleA: '1.1.1' }, peerDependencies: { moduleA: '*' } },
    };
    expect(gpv('moduleA', {}, params)).toBe('1');
  });
});

describe('getOptionalDependencyVersion', () => {
  const gov = knit.getOptionalDependencyVersion;

  it('returns version found in module package.json optionalDependencies', () => {
    const params = {
      paths: PATHS,
      pkg: { optionalDependencies: { moduleA: '>=3' } },
      rootPkg: { optionalDependencies: { moduleA: '*' } },
    };
    expect(gov('moduleA', {}, params)).toBe('>=3');
  });
  it('returns version found in root package.json optionalDependencies', () => {
    const params = {
      paths: PATHS,
      pkg: {},
      rootPkg: { optionalDependencies: { moduleA: '^1' } },
    };
    expect(gov('moduleA', {}, params)).toBe('^1');
  });
  it('returns dependencies version if optional version is *', () => {
    const params = {
      paths: PATHS,
      pkg: {},
      rootPkg: { dependencies: { moduleA: '1.1.1' }, optionalDependencies: { moduleA: '*' } },
    };
    expect(gov('moduleA', {}, params)).toBe('1.1.1');
  });
});

describe('updateModulePkg', () => {
  const ump = knit.updateModulePkg;
  const PKG = { name: 'foo' };
  const ROOT_PGK = {
    homepage: 'bar',
    license: 'bar',
    bugs: 'bar',
    tags: 'bar',
    keywords: 'bar',
    files: 'bar',
    repository: 'bar',
    engines: 'bar',
    author: 'bar',
    version: 1,
  };

  it('combines root package.json metadata with module package.json', () => {
    expect(ump(
      { internal: [], used: [], updated: [] },
      { paths: PATHS, pkg: PKG, rootPkg: ROOT_PGK }
    )).toEqual({
      ...PKG,
      ...ROOT_PGK,
      main: path.join('lib', 'index.js'),
      dependencies: {},
      optionalDependencies: {},
      peerDependencies: {},
      private: false,
      version: 1,
    });
  });
  it('lets module package.json overide metadata from root package.json', () => {
    expect(ump(
      { internal: [], used: [], updated: [] },
      { paths: PATHS, pkg: { ...PKG, homepage: 'foo' }, rootPkg: ROOT_PGK }
    )).toEqual({
      ...PKG,
      ...ROOT_PGK,
      homepage: 'foo',
      main: path.join('lib', 'index.js'),
      dependencies: {},
      optionalDependencies: {},
      peerDependencies: {},
      private: false,
      version: 1,
    });
  });
  it('uses version if passed', () => {
    expect(ump(
      { internal: [], used: [], updated: [] },
      { paths: PATHS, pkg: PKG, rootPkg: ROOT_PGK, version: 2 }
    ).version).toBe(2);
  });
  it('defaults to rootPkg version if no version passed', () => {
    expect(ump(
      { internal: [], used: [], updated: [] },
      { paths: PATHS, pkg: PKG, rootPkg: ROOT_PGK }
    ).version).toBe(1);
  });
  it('adds needed dependencies to module package.json', () => {
    expect(ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: PKG,
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '1' },
        },
      }
    ).dependencies).toEqual({ moduleA: '1' });
  });
  it('includes dependencies set in module package.json', () => {
    expect(ump(
      { internal: [], used: [], updated: [] },
      { paths: PATHS,
        pkg: { ...PKG, dependencies: { foo: '*' } },
        rootPkg: { ...ROOT_PGK, dependencies: { foo: '1.1.1' } },
      }
    )).toEqual({
      ...PKG,
      ...ROOT_PGK,
      main: path.join('lib', 'index.js'),
      dependencies: { foo: '1.1.1' },
      optionalDependencies: {},
      peerDependencies: {},
      private: false,
      version: 1,
    });
  });
  it('adds peerDependencies truncated to major version', () => {
    const pkg = ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: PKG,
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '1.1.1' },
          peerDependencies: { moduleA: '*' },
        },
      }
    );
    expect(pkg.peerDependencies).toEqual({ moduleA: '1' });
    expect(pkg.dependencies).toEqual({});
  });
  it('uses peerDependencies version if set', () => {
    const pkg = ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: PKG,
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '2' },
          peerDependencies: { moduleA: '>=1' },
        },
      }
    );
    expect(pkg.peerDependencies).toEqual({ moduleA: '>=1' });
  });
  it('uses peerDependencies version from module if set', () => {
    const pkg = ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: {
          ...PKG,
          peerDependencies: { moduleA: '>=1' },
        },
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '2' },
        },
      }
    );
    expect(pkg.peerDependencies).toEqual({ moduleA: '>=1' });
  });
  it('adds needed optionalDependencies to module package.json', () => {
    const pkg = ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: PKG,
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '1' },
          optionalDependencies: { moduleA: '*' },
        },
      }
    );
    expect(pkg.optionalDependencies).toEqual({ moduleA: '1' });
    expect(pkg.dependencies).toEqual({});
  });
  it('uses optionalDependencies version if set', () => {
    const pkg = ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: PKG,
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '2' },
          optionalDependencies: { moduleA: '>=1' },
        },
      }
    );
    expect(pkg.optionalDependencies).toEqual({ moduleA: '>=1' });
  });
  it('uses optionalDependencies version from module if set', () => {
    const pkg = ump(
      { internal: [], used: ['moduleA'], updated: [] },
      {
        paths: PATHS,
        pkg: {
          ...PKG,
          optionalDependencies: { moduleA: '>=1' },
        },
        rootPkg: {
          ...ROOT_PGK,
          dependencies: { moduleA: '2' },
        },
      }
    );
    expect(pkg.optionalDependencies).toEqual({ moduleA: '>=1' });
  });
});

describe('updateModulePkgBrowser', () => {
  const umpb = knit.updateModulePkgBrowser;

  it('adds `jsnext:main` and `browser` fields to package.json', () => {
    expect(umpb({ name: 'name' }, PATHS)).toEqual({
      name: 'name',
      'jsnext:main': path.join('jsnext', 'index.js'),
      module: path.join('jsnext', 'index.js'),
      unpkg: path.join('umd', 'index.min.js'),
    });
  });
  it('overwrites existsing values for those fields', () => {
    expect(umpb({
      name: 'name',
      'jsnext:main': 'foo',
      unpkg: 'bar',
    }, PATHS)).toEqual({
      name: 'name',
      'jsnext:main': path.join('jsnext', 'index.js'),
      module: path.join('jsnext', 'index.js'),
      unpkg: path.join('umd', 'index.min.js'),
    });
  });
});
