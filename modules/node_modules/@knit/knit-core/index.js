/* @flow weak */

const path = require('path');
const execa = require('execa');
const fs = require('fs-extra');
const readPkg = require('read-pkg');

const needle = require('@knit/needle');
const depchek = require('@knit/depcheck');

exports.isScoped = (module) => module[0] === '@';

exports.getModuleName = (module) => module.replace(/@.*?\//, '');

exports.readPkg = (dir) => {
  try {
    return readPkg.sync(path.join(needle.paths.modules, dir), {
      normalize: false,
    });
  } catch (err) {
    throw {
      message: `could not find a \`package.json\` in ${path.join(needle.paths.modulesStub, dir)}.`,
      stderr: `All directories under ${needle.paths.modulesStub} are expected to be node modules. To ignore a directory add a 'private: true' to the package.json.`,
    };
  }
};

exports.findDependencies = (dir) => (
   depchek(path.join(needle.paths.modules, dir))
    .then(res => Object.keys(res.using))
    .then(using => {
      const pkg = exports.readPkg(dir);
      const deps = Object.keys((pkg || {}).dependencies || {});

      return using.concat(deps);
    })
);

exports.findMissingDependencies = (using, modules) => {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return using.filter(m => !installed.includes(m) && !modules.includes(m));
};

exports.findUnusedDependencies = (using, modules) => {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return installed.filter(m => !using.includes(m) && !modules.includes(m));
};

exports.findInternalDependencies = (using, modules) => (
   using.filter(m => (
    modules.includes(m)
  ))
);

exports.findModules = () => {
  try {
    return fs.readdirSync(needle.paths.modules)
      .reduce((acc, d) => {
        if (exports.isScoped(d)) {
          return acc.concat(fs.readdirSync(path.join(needle.paths.modules, d)).map(dir => path.join(d, dir)));
        }

        return acc.concat(d);
      }, []).filter(d => fs.statSync(path.join(needle.paths.modules, d)).isDirectory());
  } catch (err) {
    throw {
      message: 'Modules directory could not be read.',
      stderr: `Make sure your modules are in \`${needle.paths.modulesStub}\``,
    };
  }
};

exports.findPublicModules = () => (
   exports.findModules().filter(m => {
     const pkg = exports.readPkg(m);
     return pkg && !pkg.private;
   })
);

exports.findModifiedSince = (modules, tag) => {
  const output = execa.sync('git', ['diff', '--dirstat=files,0', tag, '--', needle.paths.modulesStub]);
  const lines = (output.stdout || '').split('\n').filter(x => x.length);

  const modified = lines.map(l => {
    const [scope, name] = l.split(`${needle.paths.modulesStub}/`)[1].split('/');
    return exports.isScoped(scope) ? [scope, name].join('/') : scope;
  }).filter(
    Boolean
  ).reduce(
    (acc, m) =>
       (acc.includes(m) ? acc : acc.concat(m))
  , []).filter(
    m => modules.includes(m)
  );

  return modified;
};

exports.findAllDependencies = (modules) => (
   modules.reduce((acc, mod) =>
     Promise.all([acc, exports.findDependencies(mod)]).then(
      vals => (
        vals[0].concat(vals[1], modules)
      )
    ).then(ms => (
      ms.reduce((a, m) => (
        (a.includes(m) ? a : a.concat(m))
      ), [])
    ))
  , [])
);

exports.findAllMissingDependencies = (modules) => (
  exports.findAllDependencies(modules).then(using => (
    exports.findMissingDependencies(using, modules)
  ))
);

exports.findAllUnusedDependencies = (modules) => (
  exports.findAllDependencies(modules).then(using => (
    exports.findUnusedDependencies(using, modules)
  ))
);

exports.makeDependencyMap = (modules) => (
  modules.reduce((acc, m) => (
    Promise.all([acc, exports.findDependencies(m)]).then(
      vals => Object.assign({}, vals[0], {
        [m]: vals[1],
      })
    )
  ), {})
);

exports.resolveCascadingUpdates = (modules, mapping, modified) => {
  const next = modules.reduce((acc, module) => {
    if (acc.includes(module)) return acc;
    const deps = mapping[module] || [];

    if (deps.some(d => acc.includes(d))) {
      return acc.concat(module);
    }

    return acc;
  }, modified);

  if (next.length !== modified.length) {
    return exports.resolveCascadingUpdates(modules, mapping, next);
  }

  return modified;
};

exports.findUpdatedSince = (modules, tag) => {
  // files modified according to git
  const modifiedModules = exports.findModifiedSince(modules, tag);
  // map of {module: [module dependencies]}
  return exports.makeDependencyMap(modules).then(dependencyMap =>
     exports.resolveCascadingUpdates(modules, dependencyMap, modifiedModules)
  );
};

exports.getDependencyVersion = (dep, modules, updated, nextVersion) => {
  if (needle.pkg.dependencies && needle.pkg.dependencies[dep]) {
    return needle.pkg.dependencies[dep];
  } else if (updated.includes(dep)) {
    return nextVersion;
  } else if (modules.includes(dep)) {
    const pkg = exports.readPkg(dep);
    if (pkg && pkg.version) {
      return pkg.version;
    }
  }

  throw {
    message: `Missing dependency: ${dep}`,
    stderr: `Could not find ${dep} in the project package.json. Try \`yarn add ${dep}\`.`,
  };
};

exports.getPeerDependencyVersion = (dep, modules, updated, nextVersion) => {
  if (needle.pkg.dependencies && needle.pkg.dependencies[dep]) {
    return needle.pkg.dependencies[dep];
  } else if (updated.includes(dep)) {
    return nextVersion;
  } else if (modules.includes(dep)) {
    const pkg = exports.readPkg(dep);
    if (pkg && pkg.version) {
      return pkg.version;
    }
  }

  throw {
    message: `Missing dependency: ${dep}`,
    stderr: `Could not find ${dep} in the project package.json. Try \`yarn add ${dep}\`.`,
  };
};

exports.updateModulePkg = (pkg, modules, used, updated, version) => {
  const projectPkg = needle.pkg;
  const nextVersion = version || projectPkg.version;

  return (
    Object.assign({},
      {
        homepage: projectPkg.homepage,
        license: projectPkg.license,
        bugs: projectPkg.bugs,
        tags: projectPkg.tags,
        keywords: projectPkg.keywords,
        files: projectPkg.files,
        repository: projectPkg.repository,
        engines: projectPkg.engines,
        author: projectPkg.author,
        private: false,
      },
      pkg,
      {
        main: path.join(needle.paths.distStub, needle.paths.libStub, 'index.js'),
        // fall back to project package if no version given in workflow
        version: nextVersion,
        dependencies: used.concat(Object.keys(pkg.dependencies || {})).filter(d => (
          !Object.keys(projectPkg.peerDependencies || {}).includes(d)
        )).reduce((acc, d) => (
          Object.assign(acc, {
            [d]: exports.getDependencyVersion(d, modules, updated, nextVersion),
          })
        ), {}),
        peerDependencies: used.filter(d => (
          Object.keys(projectPkg.peerDependencies || {}).includes(d)
        )).reduce((acc, d) => (
          Object.assign(acc, {
            [d]: parseInt(exports.getPeerDependencyVersion(d, modules, updated, nextVersion).replace(/^[^\d]/, ''), 10).toString(),
          })
        ), {}),
      }
    )
  );
};

exports.updateModulePkgBrowser = (pkg) => (
  Object.assign({},
    pkg,
    {
      'jsnext:main': path.join(needle.paths.distStub, needle.paths.es6Stub, 'index.js'),
      browser: path.join(needle.paths.distStub, needle.paths.umdStub, 'index.min.js'),
    }
  )
);
