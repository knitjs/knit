/* @flow */

import type { TPkgJson, TPkgJsonDeps, TPaths } from '@knit/needle';

const path = require('path');
const execa = require('execa');
const fs = require('fs-extra');
const rp = require('read-pkg');

const depcheck = require('@knit/depcheck');

export type TModules = Array<string>;

type TIsScoped = (m: TModules) => boolean;
export const isScoped: TIsScoped = (module) => module[0] === '@';

type TGetModuleName = (m: string) => string;
export const getModuleName: TGetModuleName = (module) => module.replace(/@.*?\//, '');

type TGetModuleFromDir = (d: string) => string;
export const getModuleFromDir: TGetModuleFromDir = (dir) => dir.replace(path.sep, '/');

type TPathJoin = (p: string) => string;
export const pathJoin: TPathJoin = (...paths) => path.join(...paths).replace('/', path.sep);

type TReadPkg = (m: string, p: TPaths) => TPkgJson;
export const readPkg: TReadPkg = (mod, paths) => {
  try {
    return rp.sync(pathJoin(paths.modules, mod), {
      normalize: false,
    });
  } catch (err) {
    throw {
      message: `could not find a \`package.json\` in ${pathJoin(paths.modulesStub, mod)}.`,
      stderr: `All directories under ${paths.modulesStub} are expected to be node modules. To ignore a directory add a 'private: true' to the package.json.`,
    };
  }
};

type TFindDependencies = (m: string, p: TPaths) => Promise<TModules>;
export const findDependencies: TFindDependencies = (mod, paths) => (
   depcheck(pathJoin(paths.modules, mod))
    .then(res => Object.keys(res.using))
    .then(using => {
      const pkg = readPkg(mod, paths);
      const deps = Object.keys((pkg || {}).dependencies || {});

      return using.concat(deps);
    })
    .then(using => using.reduce((acc, d) => (acc.includes(d) ? acc : acc.concat(d)), []))
    .then(using => using.sort())
    .catch(e => {
      throw e;
    })
);

type TFindMissingDependencies = (u: TModules, m: TModules, d: TPkgJsonDeps) => TModules;
export const findMissingDependencies: TFindMissingDependencies = (using, modules, deps) => {
  const installed = Object.keys(deps);

  return using.filter(m => !installed.includes(m) && !modules.includes(m));
};

type TFindUnusedDependencies = (u: TModules, m: TModules, d: TPkgJsonDeps) => TModules;
export const findUnusedDependencies: TFindUnusedDependencies = (using, modules, deps) => {
  const installed = Object.keys(deps);

  return installed.filter(m => !using.includes(m) && !modules.includes(m));
};

type TFindInternalDependencies = (u: TModules, m: TModules) => TModules;
export const findInternalDependencies: TFindInternalDependencies = (using, modules) => (
   using.filter(m => (
    modules.includes(m)
  ))
);

type TFindModules = (p: TPaths) => TModules;
export const findModules: TFindModules = (paths) => {
  try {
    return fs.readdirSync(paths.modules)
      .reduce((acc, d) => (
        isScoped(d)
          ? acc.concat(fs.readdirSync(pathJoin(paths.modules, d)).map(dir => pathJoin(d, dir)))
          : acc.concat(d)
      ), [])
      .filter(d => fs.statSync(pathJoin(paths.modules, d)).isDirectory())
      .map(getModuleFromDir);
  } catch (err) {
    throw {
      message: 'Modules directory could not be read.',
      stderr: `Make sure your modules are in \`${paths.modulesStub}\``,
    };
  }
};

type TFindPublicModules = (p: TPaths) => TModules;
export const findPublicModules: TFindPublicModules = (paths) => (
   findModules(paths).filter(m => {
     const pkg = readPkg(m, paths);
     return pkg && !pkg.private;
   })
);

type TFindModifiedSince = (m: TModules, tag: string, paths: TPaths) => TModules;
export const findModifiedSince: TFindModifiedSince = (modules, tag, paths) => {
  const output = execa.sync('git', ['diff', '--dirstat=files,0', tag, '--', paths.modulesStub]);
  const lines = (output.stdout || '').split('\n').filter(x => x.length);

  const modified = lines.map(l => {
    const [scope, name] = l.split(`${paths.modulesStub}/`)[1].split('/');
    return isScoped(scope) ? [scope, name].join('/') : scope;
  }).filter(
    Boolean
  ).reduce(
    (acc, m) =>
       (acc.includes(m) ? acc : acc.concat(m))
  , []).filter(
    m => modules.includes(m)
  );

  return modified;
};

type TFindAllDependencies = (m: TModules, p: TPaths) => Promise<TModules>;
export const findAllDependencies: TFindAllDependencies = async (modules, paths) => (
  (await Promise.all(modules.reduce((acc, mod) => {
    const deps = findDependencies(mod, paths);
    return acc.concat(deps);
  }, [])))
  .reduce((a, m) => (
    (a.includes(m) ? a : a.concat(m))
  ), [])
);

type TFindAllMissingDependencies = (m: TModules, p: TPaths, rootPkg: TPkgJson) => Promise<TModules>;
export const findAllMissingDependencies: TFindAllMissingDependencies = (modules, paths, rootPkg) => (
  findAllDependencies(modules, paths).then(using => (
    findMissingDependencies(using, modules, rootPkg.dependencies)
  ))
);

type TFindAllUnusedDependencies = (m: TModules, p: TPaths, rootPkg: TPkgJson) => Promise<TModules>;
export const findAllUnusedDependencies: TFindAllUnusedDependencies = (modules, paths, rootPkg) => (
  findAllDependencies(modules, paths).then(using => (
    findUnusedDependencies(using, modules, rootPkg.dependencies)
  ))
);

type TMakeDependencyMap = (m: TModules, p: TPaths) => Promise<{[k: string]: TModules}>;
export const makeDependencyMap: TMakeDependencyMap = async (modules, paths) => (
  modules.reduce(async (acc, mod) => ({
    ...await acc,
    [mod]: await findDependencies(mod, paths),
  }), {})
);

type TResolveCascadingUpdates = (modules: TModules, mapping: {[k: string]: TModules}, modified: TModules) => TModules;
export const resolveCascadingUpdates: TResolveCascadingUpdates = (modules, mapping, modified) => {
  const next = modules.reduce((acc, module) => {
    if (acc.includes(module)) return acc;
    const deps = mapping[module] || [];

    if (deps.some(d => acc.includes(d))) {
      return acc.concat(module);
    }

    return acc;
  }, modified);

  if (next.length !== modified.length) {
    return resolveCascadingUpdates(modules, mapping, next);
  }

  return modified;
};

type TFindUpdatedModules = (modu: TModules, modi: TModules, paths: TPaths) => Promise<TModules>;
export const findUpdatedModules: TFindUpdatedModules = (modules, modified, paths) => (
  // map of {module: [module dependencies]}
   makeDependencyMap(modules, paths).then(dependencyMap =>
     resolveCascadingUpdates(modules, dependencyMap, modified)
  )
);

type TGetDependencyVersion = (d: string, m: {internal: TModules, updated: TModules}, p: { nextVersion: string, paths: TPaths, rootPkg: TPkgJson}) => string;
export const getDependencyVersion: TGetDependencyVersion = (dep, modules, params) => {
  if (params.rootPkg.dependencies && params.rootPkg.dependencies[dep]) {
    return params.rootPkg.dependencies[dep];
  } else if (modules.updated.includes(dep)) {
    return params.nextVersion;
  } else if (modules.internal.includes(dep)) {
    const pkg = readPkg(dep, params.paths);
    if (pkg && pkg.version) {
      return pkg.version;
    }
  }

  throw {
    message: `Missing dependency: ${dep}`,
    stderr: `Could not find ${dep} in the project package.json. Try \`yarn add ${dep}\`.`,
  };
};

type TGetPeerDependencyVersion = (d: string, m: {internal: TModules, updated: TModules}, p: { nextVersion: string, paths: TPaths, pkg: TPkgJson, rootPkg: TPkgJson}) => string;
export const getPeerDependencyVersion: TGetPeerDependencyVersion = (dep, modules, params) => {
  const version = (params.pkg.peerDependencies && params.pkg.peerDependencies[dep])
    ? params.pkg.peerDependencies[dep]
    : params.rootPkg.peerDependencies[dep];

  if (version === '*') {
    const v = (params.rootPkg.devDependencies && params.rootPkg.devDependencies[dep])
      ? params.rootPkg.devDependencies[dep]
      : getDependencyVersion(dep, modules, params);

    return parseInt(v.replace(/^[^\d]/, ''), 10).toString();
  }

  return version;
};

type TGetOptionalDependencyVersion = (d: string, m: {internal: TModules, updated: TModules}, p: { nextVersion: string, paths: TPaths, pkg: TPkgJson, rootPkg: TPkgJson}) => string;
export const getOptionalDependencyVersion: TGetOptionalDependencyVersion = (dep, modules, params) => {
  const version = (params.pkg.optionalDependencies && params.pkg.optionalDependencies[dep])
    ? params.pkg.optionalDependencies[dep]
    : params.rootPkg.optionalDependencies[dep];

  if (version === '*') {
    return getDependencyVersion(dep, modules, params);
  }

  return version;
};

type TUpdateModulePkg = (m: {internal: TModules, updated: TModules, used: TModules }, p: { paths: TPaths, pkg: TPkgJson, rootPkg: TPkgJson, version: ?string }) => TPkgJson;
export const updateModulePkg: TUpdateModulePkg = (modules, params) => {
  const deps = modules.used.concat(Object.keys(params.pkg.dependencies || {}));
  const peers = Object.keys(params.pkg.peerDependencies || {}).concat(
    Object.keys(params.rootPkg.peerDependencies || {})
  );
  const opts = Object.keys(params.pkg.optionalDependencies || {}).concat(
    Object.keys(params.rootPkg.optionalDependencies || {})
  );
  const nextVersion = params.version || params.rootPkg.version;

  return ({
    homepage: params.rootPkg.homepage,
    license: params.rootPkg.license,
    bugs: params.rootPkg.bugs,
    tags: params.rootPkg.tags,
    keywords: params.rootPkg.keywords,
    files: params.rootPkg.files,
    repository: params.rootPkg.repository,
    engines: params.rootPkg.engines,
    author: params.rootPkg.author,
    private: false,
    ...params.pkg,
    ...{
      main: pathJoin(params.paths.lib, 'index.js'),
        // fall back to project package if no version given in workflow
      version: nextVersion,
      dependencies: deps.filter(d => !peers.includes(d) && !opts.includes(d)).reduce((acc, d) => ({
        ...acc,
        [d]: getDependencyVersion(d, modules, { ...params, nextVersion }),
      }), {}),
      peerDependencies: peers.reduce((acc, d) => ({
        ...acc,
        [d]: getPeerDependencyVersion(d, modules, { ...params, nextVersion }),
      }), {}),
      optionalDependencies: opts.reduce((acc, d) => ({
        ...acc,
        [d]: getOptionalDependencyVersion(d, modules, { ...params, nextVersion }),
      }), {}),
    },
  });
};

type TUpdateModulePkgBrowser = (p: TPkgJson, paths: TPaths) => TPkgJson;
export const updateModulePkgBrowser: TUpdateModulePkgBrowser = (pkg, paths) => ({
  ...pkg,
  ...{
    'jsnext:main': pathJoin(paths.jsnext, 'index.js'),
    browser: pathJoin(paths.umd, 'index.min.js'),
  },
});
