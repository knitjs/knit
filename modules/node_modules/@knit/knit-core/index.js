/* @flow */

import path from 'path';
import execa from 'execa';
import fs from 'fs-extra';
import * as rp from 'read-pkg';

import needle from '@knit/needle';
import depchek from '@knit/depcheck';

import type { TPkgJson } from '@knit/needle';

export type TModules = Array<string>;

type TIsScoped = (m: TModules) => boolean;
export const isScoped: TIsScoped = (module) => module[0] === '@';

type TGetModuleName = (m: string) => string;
export const getModuleName: TGetModuleName = (module) => module.replace(/@.*?\//, '');

type TReadPkg = (d: string) => TPkgJson;
export const readPkg: TReadPkg = (dir) => {
  try {
    return rp.sync(path.join(needle.paths.modules, dir), {
      normalize: false,
    });
  } catch (err) {
    throw {
      message: `could not find a \`package.json\` in ${path.join(needle.paths.modulesStub, dir)}.`,
      stderr: `All directories under ${needle.paths.modulesStub} are expected to be node modules. To ignore a directory add a 'private: true' to the package.json.`,
    };
  }
};

type TFindDependencies = (dir: string) => Promise<TModules>;
export const findDependencies: TFindDependencies = (dir) => (
   depchek(path.join(needle.paths.modules, dir))
    .then(res => Object.keys(res.using))
    .then(using => {
      const pkg = readPkg(dir);
      const deps = Object.keys((pkg || {}).dependencies || {});

      return using.concat(deps);
    })
    .then(using => using.reduce((acc, d) => (acc.includes(d) ? acc : acc.concat(d)), []))
    .then(using => using.sort())
);

type TFindMissingDependencies = (u: TModules, m: TModules) => TModules;
export const findMissingDependencies: TFindMissingDependencies = (using, modules) => {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return using.filter(m => !installed.includes(m) && !modules.includes(m));
};

type TFindUnusedDependencies = (u: TModules, m: TModules) => TModules;
export const findUnusedDependencies: TFindUnusedDependencies = (using, modules) => {
  const installed = Object.keys(needle.pkg.dependencies || {});

  return installed.filter(m => !using.includes(m) && !modules.includes(m));
};

type TFindInternalDependencies = (u: TModules, m: TModules) => TModules;
export const findInternalDependencies: TFindInternalDependencies = (using, modules) => (
   using.filter(m => (
    modules.includes(m)
  ))
);

type TFindModules = () => TModules;
export const findModules: TFindModules = () => {
  try {
    return fs.readdirSync(needle.paths.modules)
      .reduce((acc, d) => (
        isScoped(d)
          ? acc.concat(fs.readdirSync(path.join(needle.paths.modules, d)).map(dir => path.join(d, dir)))
          : acc.concat(d)
      ), []).filter(d => fs.statSync(path.join(needle.paths.modules, d)).isDirectory());
  } catch (err) {
    throw {
      message: 'Modules directory could not be read.',
      stderr: `Make sure your modules are in \`${needle.paths.modulesStub}\``,
    };
  }
};

type TFindPublicModules = () => TModules;
export const findPublicModules: TFindPublicModules = () => (
   findModules().filter(m => {
     const pkg = readPkg(m);
     return pkg && !pkg.private;
   })
);

type TFindModifiedSince = (m: TModules, tag: string) => TModules;
export const findModifiedSince: TFindModifiedSince = (modules, tag) => {
  const output = execa.sync('git', ['diff', '--dirstat=files,0', tag, '--', needle.paths.modulesStub]);
  const lines = (output.stdout || '').split('\n').filter(x => x.length);

  const modified = lines.map(l => {
    const [scope, name] = l.split(`${needle.paths.modulesStub}/`)[1].split('/');
    return isScoped(scope) ? [scope, name].join('/') : scope;
  }).filter(
    Boolean
  ).reduce(
    (acc, m) =>
       (acc.includes(m) ? acc : acc.concat(m))
  , []).filter(
    m => modules.includes(m)
  );

  return modified;
};

type TFindAllDependencies = (m: TModules) => Promise<TModules>;
export const findAllDependencies: TFindAllDependencies = (modules) => (
   modules.reduce((acc, mod) =>
     Promise.all([acc, findDependencies(mod)]).then(
      vals => (
        vals[0].concat(vals[1], modules)
      )
    ).then(ms => (
      ms.reduce((a, m) => (
        (a.includes(m) ? a : a.concat(m))
      ), [])
    ))
  , [])
);

type TFindAllMissingDependencies = (m: TModules) => Promise<TModules>;
export const findAllMissingDependencies: TFindAllMissingDependencies = (modules) => (
  findAllDependencies(modules).then(using => (
    findMissingDependencies(using, modules)
  ))
);

type TFindAllUnusedDependencies = (m: TModules) => Promise<TModules>;
export const findAllUnusedDependencies: TFindAllUnusedDependencies = (modules) => (
  findAllDependencies(modules).then(using => (
    findUnusedDependencies(using, modules)
  ))
);

type TMakeDependencyMap = (m: TModules) => Promise<{[k: string]: TModules}>;
export const makeDependencyMap: TMakeDependencyMap = (modules) => (
  modules.reduce((acc, m) => (
    Promise.all([acc, findDependencies(m)]).then(
      vals => ({
        ...vals[0],
        [m]: vals[1],
      })
    )
  ), {})
);

type TResolveCascadingUpdates = (m: TModules, mp: {[k: string]: TModules}, total: TModules) => TModules;
export const resolveCascadingUpdates: TResolveCascadingUpdates = (modules, mapping, modified) => {
  const next = modules.reduce((acc, module) => {
    if (acc.includes(module)) return acc;
    const deps = mapping[module] || [];

    if (deps.some(d => acc.includes(d))) {
      return acc.concat(module);
    }

    return acc;
  }, modified);

  if (next.length !== modified.length) {
    return resolveCascadingUpdates(modules, mapping, next);
  }

  return modified;
};

type TFindUpdatedSince = (m: TModules, tag: string) => Promise<TModules>;
export const findUpdatedSince: TFindUpdatedSince = (modules, tag) => {
  // files modified according to git
  const modifiedModules = findModifiedSince(modules, tag);
  // map of {module: [module dependencies]}
  return makeDependencyMap(modules).then(dependencyMap =>
     resolveCascadingUpdates(modules, dependencyMap, modifiedModules)
  );
};

type TGetDependencyVersion = (d: string, m: TModules, u: TModules, v: string) => string;
export const getDependencyVersion: TGetDependencyVersion = (dep, modules, updated, nextVersion) => {
  if (needle.pkg.dependencies && needle.pkg.dependencies[dep]) {
    return needle.pkg.dependencies[dep];
  } else if (updated.includes(dep)) {
    return nextVersion;
  } else if (modules.includes(dep)) {
    const pkg = readPkg(dep);
    if (pkg && pkg.version) {
      return pkg.version;
    }
  }

  throw {
    message: `Missing dependency: ${dep}`,
    stderr: `Could not find ${dep} in the project package.json. Try \`yarn add ${dep}\`.`,
  };
};

type TGetPeerDependencyVersion = (pkg: TPkgJson, d: string, m: TModules, u: TModules, v: string) => string;
export const getPeerDependencyVersion: TGetPeerDependencyVersion = (pkg, dep, modules, updated, nextVersion) => {
  const version = (pkg.peerDependencies && pkg.peerDependencies[dep])
    ? pkg.peerDependencies[dep]
    // $FlowIgnore
    : needle.pkg.peerDependencies[dep];

  if (version === '*') {
    const v = (needle.pkg.devDependencies && needle.pkg.devDependencies[dep])
      ? needle.pkg.devDependencies[dep]
      : getDependencyVersion(dep, modules, updated, nextVersion);

    return parseInt(v.replace(/^[^\d]/, ''), 10).toString();
  }

  return version;
};

type TGetOptionalDependencyVersion = (pkg: TPkgJson, d: string, m: TModules, u: TModules, v: string) => string;
export const getOptionalDependencyVersion: TGetOptionalDependencyVersion = (pkg, dep, modules, updated, nextVersion) => {
  const version = (pkg.optionalDependencies && pkg.optionalDependencies[dep])
    ? pkg.optionalDependencies[dep]
    // $FlowIgnore
    : needle.pkg.optionalDependencies[dep];

  if (version === '*') {
    const v = getDependencyVersion(dep, modules, updated, nextVersion);

    return parseInt(v.replace(/^[^\d]/, ''), 10).toString();
  }

  return version;
};

type TUpdateModulePkg = (m: TPkgJson, ms: TModules, used: TModules, updated: TModules, version: ?string) => TPkgJson;
export const updateModulePkg: TUpdateModulePkg = (pkg, modules, used, updated, version) => {
  const projectPkg = needle.pkg;
  const deps = used.concat(Object.keys(pkg.dependencies || {}));
  const peers = Object.keys(pkg.peerDependencies || {}).concat(
    Object.keys(projectPkg.peerDependencies || {})
  );
  const opts = Object.keys(pkg.optionalDependencies || {}).concat(
    Object.keys(projectPkg.optionalDependencies || {})
  );
  const nextVersion = version || projectPkg.version;

  return ({
    homepage: projectPkg.homepage,
    license: projectPkg.license,
    bugs: projectPkg.bugs,
    tags: projectPkg.tags,
    keywords: projectPkg.keywords,
    files: projectPkg.files,
    repository: projectPkg.repository,
    engines: projectPkg.engines,
    author: projectPkg.author,
    private: false,
    ...pkg,
    ...{
      main: path.join(needle.paths.distStub, needle.paths.libStub, 'index.js'),
        // fall back to project package if no version given in workflow
      version: nextVersion,
      dependencies: deps.filter(d => !peers.includes(d)).reduce((acc, d) => ({
        ...acc,
        [d]: getDependencyVersion(d, modules, updated, nextVersion),
      }), {}),
      peerDependencies: peers.reduce((acc, d) => ({
        ...acc,
        [d]: getPeerDependencyVersion(pkg, d, modules, updated, nextVersion),
      }), {}),
      optionalDependencies: opts.reduce((acc, d) => ({
        ...acc,
        [d]: getOptionalDependencyVersion(pkg, d, modules, updated, nextVersion),
      }), {}),
    },
  });
};

type TUpdateModulePkgBrowser = (p: TPkgJson) => TPkgJson;
export const updateModulePkgBrowser: TUpdateModulePkgBrowser = (pkg) => ({
  ...pkg,
  ...{
    'jsnext:main': path.join(needle.paths.distStub, needle.paths.es6Stub, 'index.js'),
    browser: path.join(needle.paths.distStub, needle.paths.umdStub, 'index.min.js'),
  },
});
