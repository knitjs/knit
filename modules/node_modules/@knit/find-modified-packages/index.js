/* 2flow */

import type { TPaths } from '@knit/needle';
import type { TModules } from '@knit/knit-core';

import execa from 'execa';

import { makeDependencyMap } from '@knit/find-dependencies';
import isScoped from '@knit/is-scoped';


type TResolveCascadingUpdates = (modules: TModules, mapping: {[k: string]: TModules}, modified: TModules) => TModules;
export const resolveCascadingUpdates: TResolveCascadingUpdates = (modules, mapping, modified) => {
  const next = modules.reduce((acc, module) => {
    if (acc.includes(module)) return acc;
    const deps = mapping[module] || [];

    if (deps.some(d => acc.includes(d))) {
      return acc.concat(module);
    }

    return acc;
  }, modified);

  if (next.length !== modified.length) {
    return resolveCascadingUpdates(modules, mapping, next);
  }

  return modified;
};

type TFindModifiedPackages = (modu: TModules, modi: TModules, paths: TPaths) => Promise<TModules>;
export const findModifiedPackages: TFindModifiedPackages = (modules, modified, paths) => (
  // map of {module: [module dependencies]}
   makeDependencyMap(modules, paths).then(dependencyMap =>
     resolveCascadingUpdates(modules, dependencyMap, modified)
  )
);

type TFindModifiedSince = (m: TModules, tag: string, paths: TPaths) => TModules;
export const findModifiedSince: TFindModifiedSince = (modules, tag, paths) => {
  const output = execa.sync('git', ['diff', '--dirstat=files,0', tag, '--', paths.modulesStub]);
  const lines = (output.stdout || '').split('\n').filter(x => x.length);

  const modified = lines.map(l => {
    const [scope, name] = l.split(`${paths.modulesStub}/`)[1].split('/');
    return isScoped(scope) ? [scope, name].join('/') : scope;
  }).filter(
    Boolean
  ).reduce(
    (acc, m) =>
       (acc.includes(m) ? acc : acc.concat(m))
  , []).filter(
    m => modules.includes(m)
  );

  return modified;
};
